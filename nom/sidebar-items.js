initSidebarItems({"macro":[["alt!","try a list of parser, return the result of the first successful one"],["alt_parser!",""],["call!",""],["chain!","chains parsers and assemble the results through a closure"],["chaining_parser!",""],["closure!",""],["cond!",""],["count!",""],["dbg!",""],["dbg_dmp!",""],["delimited!","delimited(opening, X, closing) returns X"],["filter!","returns the longest list of bytes until the provided parser fails"],["flat_map_impl!","derives flat_map implementation for a list of specific IResult types"],["flat_map_ref_impl!","derives flat_map implementation for a list of IResult types with referenced types like str or vectors"],["is_a!","returns the longest list of bytes that appear in the provided array"],["is_not!","returns the longest list of bytes that do not appear in the provided array"],["length_value!","returns"],["many0!","Applies the parser 0 or more times and returns the list of results in a Vec"],["many1!","Applies the parser 1 or more times and returns the list of results in a Vec"],["map!","maps a function on the result of a parser"],["map2_ref_impl!",""],["map_opt!","maps a function returning an Option on the output of a parser"],["map_ref_impl!","derives map_opt and map_res implementations for a list of IResult types with referenced types like str or vectors"],["map_res!","maps a function returning a Result on the output of a parser"],["named!",""],["opt!","make the underlying parser optional"],["pair!","pair(X,Y), returns (x,y)"],["peek!","returns a result without consuming the input"],["preceded!","preceded(opening, X) returns X"],["pusher!","Prepares a parser function for a push pipeline"],["separated_list!","separated_list(sep, X) returns Vec<X>"],["separated_nonempty_list!","separated_nonempty_list(sep, X) returns Vec<X>"],["separated_pair!","separated_pair(X,sep,Y) returns (x,y)"],["tag!","declares a byte array as a suite to recognize"],["take!","generates a parser consuming the specified number of bytes"],["take_until!",""],["take_until_and_consume!","generates a parser consuming bytes until the specified byte sequence is found"],["take_until_either!",""],["take_until_either_and_consume!",""],["terminated!","terminated(X, closing) returns X"]],"mod":[["consumer","Data consumers"],["internal","Basic types to build the parsers"],["map","Basic combination functions"],["nom","Useful parser combinators"],["producer","Data producers"],["util",""]]});